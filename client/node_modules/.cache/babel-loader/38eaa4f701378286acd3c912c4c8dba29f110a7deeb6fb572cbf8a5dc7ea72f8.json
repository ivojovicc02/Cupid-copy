{"ast":null,"code":"var net = require('net');\nvar http = require('http');\nvar crypto = require('crypto');\nvar express = require('express');\nvar expressWs = require('express-ws');\nvar bodyParser = require('body-parser');\nfunction generateToken() {\n  return crypto.randomBytes(32).toString('hex');\n}\nfunction checkTo(allowed, requested) {\n  if (!(allowed instanceof Array)) {\n    allowed = [allowed];\n  }\n\n  // For each rule\n  for (var i = 0; i < allowed.length; i++) {\n    var to = allowed[i];\n    if ((to.host == requested.host || !to.host) && (to.port == requested.port || !to.port)) {\n      if (to.blacklist) {\n        // This item is blacklisted\n        return false;\n      } else {\n        // Otheriwse, it's whitelisted\n        return true;\n      }\n    }\n  }\n\n  // No rule found, access denied\n  return false;\n}\nmodule.exports = function (options, connectionListener) {\n  options = options || {};\n  var app = express();\n  var jsonParser = bodyParser.json();\n  var urlRoot = options.urlRoot || '/api/vm/net';\n  var server;\n  if (options.server) {\n    server = options.server;\n  } else {\n    server = http.createServer();\n  }\n  var sockets = {};\n  if (options.allowOrigin) {\n    var allowOrigin = options.allowOrigin;\n    if (typeof options.allowOrigin != 'string') {\n      allowOrigin = options.allowOrigin === true ? '*' : '';\n    }\n    if (allowOrigin) {\n      // Set Access-Control headers (CORS)\n      app.use(function (req, res, next) {\n        if (req.path.indexOf(urlRoot) !== 0) {\n          next();\n          return;\n        }\n        res.header('Access-Control-Allow-Origin', allowOrigin);\n        if (req.method.toUpperCase() == 'OPTIONS') {\n          // Preflighted requests\n          res.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\n          res.header('Access-Control-Allow-Headers', 'Content-Type');\n          res.header('Access-Control-Max-Age', 1728000); // Access-Control headers cached for 20 days\n        }\n        next();\n      });\n    }\n  }\n  app.post(urlRoot + '/connect', jsonParser, function (req, res) {\n    var host = req.body.host,\n      port = req.body.port;\n    if (!host || !port) {\n      res.status(400).send({\n        code: 400,\n        error: 'No host and port specified'\n      });\n      return;\n    }\n    if (options.to) {\n      if (!checkTo(options.to, {\n        host: host,\n        port: port\n      })) {\n        res.status(403).send({\n          code: 403,\n          error: 'Destination not allowed'\n        });\n        return;\n      }\n    }\n    var socket = net.connect({\n      host: host,\n      port: port\n    }, function (err) {\n      if (err) {\n        res.status(500).send({\n          code: 500,\n          error: err\n        });\n        return;\n      }\n\n      // Generate a token for this connection\n      var token = generateToken();\n      sockets[token] = socket;\n\n      // Remove the socket from the list when closed\n      socket.on('end', function () {\n        if (sockets[token]) {\n          delete sockets[token];\n        }\n      });\n      console.log('Connected to ' + req.body.host + ':' + req.body.port + ' (' + token + ')');\n      var remote = socket.address();\n      res.send({\n        token: token,\n        remote: remote\n      });\n    });\n    socket.on('error', function (err) {\n      if (res.finished) {\n        console.log(\"Socket error after response closed: \" + err);\n        return;\n      }\n      res.status(502).send({\n        code: 502,\n        error: 'Socket error: ' + err.code,\n        details: err\n      });\n    });\n    if (connectionListener) {\n      connectionListener(socket);\n    }\n  });\n  var wss = expressWs(app, server);\n  app.ws(urlRoot + '/socket', function (ws, req) {\n    var token = req.query.token;\n    if (!sockets[token]) {\n      console.warn('WARN: Unknown TCP connection with token \"' + token + '\"');\n      ws.close();\n      return;\n    }\n    var socket = sockets[token];\n    //delete sockets[token];\n\n    console.log('Forwarding socket with token ' + token);\n    ws.on('message', function (chunk, flags) {\n      socket.write(flags.buffer || chunk, 'binary', function () {\n        //console.log('Sent: ', (flags.buffer || chunk).toString());\n      });\n    });\n    socket.on('data', function (chunk) {\n      //console.log('Received: ', chunk.toString());\n      // Providing a callback is important, otherwise errors can be thrown\n      ws.send(chunk, {\n        binary: true\n      }, function (err) {});\n    });\n    socket.on('end', function () {\n      console.log('TCP connection closed by remote (' + token + ')');\n      ws.close();\n    });\n    ws.on('close', function () {\n      socket.end();\n      console.log('Websocket connection closed (' + token + ')');\n    });\n  });\n  app.on('mount', function (parentApp) {\n    // @see https://github.com/strongloop/express/blob/master/lib/application.js#L615\n    parentApp.listen = function listen() {\n      server.addListener('request', this);\n      return server.listen.apply(server, arguments);\n    };\n  });\n  return app;\n};","map":{"version":3,"names":["net","require","http","crypto","express","expressWs","bodyParser","generateToken","randomBytes","toString","checkTo","allowed","requested","Array","i","length","to","host","port","blacklist","module","exports","options","connectionListener","app","jsonParser","json","urlRoot","server","createServer","sockets","allowOrigin","use","req","res","next","path","indexOf","header","method","toUpperCase","post","body","status","send","code","error","socket","connect","err","token","on","console","log","remote","address","finished","details","wss","ws","query","warn","close","chunk","flags","write","buffer","binary","end","parentApp","listen","addListener","apply","arguments"],"sources":["C:/Users/Jovici/Desktop/zavrsni/tinder-clone/node_modules/net-browserify/api.js"],"sourcesContent":["var net = require('net');\nvar http = require('http');\nvar crypto = require('crypto');\nvar express = require('express');\nvar expressWs = require('express-ws');\nvar bodyParser = require('body-parser');\n\nfunction generateToken() {\n\treturn crypto.randomBytes(32).toString('hex');\n}\n\nfunction checkTo(allowed, requested) {\n\tif (!(allowed instanceof Array)) {\n\t\tallowed = [allowed];\n\t}\n\n\t// For each rule\n\tfor (var i = 0; i < allowed.length; i++) {\n\t\tvar to = allowed[i];\n\n\t\tif ((to.host == requested.host || !to.host) && (to.port == requested.port || !to.port)) {\n\t\t\tif (to.blacklist) { // This item is blacklisted\n\t\t\t\treturn false;\n\t\t\t} else { // Otheriwse, it's whitelisted\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// No rule found, access denied\n\treturn false;\n}\n\nmodule.exports = function (options, connectionListener) {\n\toptions = options || {};\n\n\tvar app = express();\n\tvar jsonParser = bodyParser.json();\n\tvar urlRoot = options.urlRoot || '/api/vm/net';\n\n\tvar server;\n\tif (options.server) {\n\t\tserver = options.server;\n\t} else {\n\t\tserver = http.createServer();\n\t}\n\n\tvar sockets = {};\n\n\tif (options.allowOrigin) {\n\t\tvar allowOrigin = options.allowOrigin;\n\t\tif (typeof options.allowOrigin != 'string') {\n\t\t\tallowOrigin = (options.allowOrigin === true) ? '*' : '';\n\t\t}\n\n\t\tif (allowOrigin) {\n\t\t\t// Set Access-Control headers (CORS)\n\t\t\tapp.use(function (req, res, next) {\n\t\t\t\tif (req.path.indexOf(urlRoot) !== 0) {\n\t\t\t\t\tnext();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tres.header('Access-Control-Allow-Origin', allowOrigin);\n\n\t\t\t\tif (req.method.toUpperCase() == 'OPTIONS') { // Preflighted requests\n\t\t\t\t\tres.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\n\t\t\t\t\tres.header('Access-Control-Allow-Headers', 'Content-Type');\n\n\t\t\t\t\tres.header('Access-Control-Max-Age', 1728000); // Access-Control headers cached for 20 days\n\t\t\t\t}\n\t\t\t\tnext();\n\t\t\t});\n\t\t}\n\t}\n\n\tapp.post(urlRoot + '/connect', jsonParser, function (req, res) {\n\t\tvar host = req.body.host,\n\t\t\tport = req.body.port;\n\n\t\tif (!host || !port) {\n\t\t\tres.status(400).send({\n\t\t\t\tcode: 400,\n\t\t\t\terror: 'No host and port specified'\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tif (options.to) {\n\t\t\tif (!checkTo(options.to, { host: host, port: port })) {\n\t\t\t\tres.status(403).send({\n\t\t\t\t\tcode: 403,\n\t\t\t\t\terror: 'Destination not allowed'\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tvar socket = net.connect({\n\t\t\thost: host,\n\t\t\tport: port\n\t\t}, function (err) {\n\t\t\tif (err) {\n\t\t\t\tres.status(500).send({\n\t\t\t\t\tcode: 500,\n\t\t\t\t\terror: err\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Generate a token for this connection\n\t\t\tvar token = generateToken();\n\t\t\tsockets[token] = socket;\n\n\t\t\t// Remove the socket from the list when closed\n\t\t\tsocket.on('end', function () {\n\t\t\t\tif (sockets[token]) {\n\t\t\t\t\tdelete sockets[token];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconsole.log('Connected to '+req.body.host+':'+req.body.port+' ('+token+')');\n\n\t\t\tvar remote = socket.address();\n\t\t\tres.send({\n\t\t\t\ttoken: token,\n\t\t\t\tremote: remote\n\t\t\t});\n\t\t});\n\t\tsocket.on('error', function (err) {\n\t\t\tif (res.finished) {\n\t\t\t\tconsole.log(\"Socket error after response closed: \"+err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tres.status(502).send({\n\t\t\t\tcode: 502,\n\t\t\t\terror: 'Socket error: '+err.code,\n\t\t\t\tdetails: err\n\t\t\t});\n\t\t});\n\t\tif (connectionListener) {\n\t\t\tconnectionListener(socket)\n\t\t}\n\t});\n\n\tvar wss = expressWs(app, server);\n\n\tapp.ws(urlRoot + '/socket', function (ws, req) {\n\t\tvar token = req.query.token;\n\n\t\tif (!sockets[token]) {\n\t\t\tconsole.warn('WARN: Unknown TCP connection with token \"'+token+'\"');\n\t\t\tws.close();\n\t\t\treturn;\n\t\t}\n\n\t\tvar socket = sockets[token];\n\t\t//delete sockets[token];\n\n\t\tconsole.log('Forwarding socket with token '+token);\n\n\t\tws.on('message', function (chunk, flags) {\n\t\t\tsocket.write(flags.buffer || chunk, 'binary', function () {\n\t\t\t\t//console.log('Sent: ', (flags.buffer || chunk).toString());\n\t\t\t});\n\t\t});\n\t\tsocket.on('data', function (chunk) {\n\t\t\t//console.log('Received: ', chunk.toString());\n\t\t\t// Providing a callback is important, otherwise errors can be thrown\n\t\t\tws.send(chunk, { binary: true }, function (err) {});\n\t\t});\n\t\tsocket.on('end', function () {\n\t\t\tconsole.log('TCP connection closed by remote ('+token+')');\n\t\t\tws.close();\n\t\t});\n\t\tws.on('close', function () {\n\t\t\tsocket.end();\n\t\t\tconsole.log('Websocket connection closed ('+token+')');\n\t\t});\n\t});\n\n\tapp.on('mount', function (parentApp) {\n\t\t// @see https://github.com/strongloop/express/blob/master/lib/application.js#L615\n\t\tparentApp.listen = function listen() {\n\t\t\tserver.addListener('request', this);\n\t\t\treturn server.listen.apply(server, arguments);\n\t\t};\n\t});\n\n\treturn app;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}